<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Carrusel 3D Interactivo</title>
  <style>
    /* ==============================
       RESET / BASE
       ============================== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 50% 35%, rgba(48, 92, 160, 0.18), transparent 30%),
        radial-gradient(circle at 80% 20%, rgba(110, 130, 160, 0.1), transparent 28%),
        linear-gradient(160deg, #07121f 0%, #0a1627 35%, #11141b 70%, #1a1c20 100%);
      color: #f2f6fb;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        linear-gradient(to bottom, rgba(255,255,255,0.03), transparent 18%),
        radial-gradient(circle at center, transparent 55%, rgba(0,0,0,0.32) 100%);
      z-index: 1;
    }

    /* ==============================
       UI OVERLAY
       ============================== */
    .ui {
      position: fixed;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }

    .headline {
      position: absolute;
      top: 32px;
      left: 32px;
      max-width: 420px;
      pointer-events: none;
    }

    .eyebrow {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(220, 232, 245, 0.7);
      margin-bottom: 10px;
    }

    .headline h1 {
      font-size: clamp(1.75rem, 4vw, 3.5rem);
      line-height: 0.96;
      font-weight: 600;
      letter-spacing: -0.03em;
      margin-bottom: 12px;
    }

    .headline p {
      font-size: 0.95rem;
      line-height: 1.5;
      color: rgba(224, 234, 246, 0.76);
      max-width: 360px;
    }

    .hint {
      position: absolute;
      right: 24px;
      bottom: 24px;
      padding: 12px 14px;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      background: rgba(10, 16, 26, 0.5);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: rgba(235, 243, 252, 0.72);
      font-size: 12px;
      line-height: 1.45;
      max-width: 240px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.25);
      pointer-events: none;
    }

    .hint strong {
      color: rgba(255,255,255,0.94);
      font-weight: 600;
    }

    /* Canvas de Three.js */
    #app {
      position: fixed;
      inset: 0;
      z-index: 2;
      cursor: grab;
      outline: none;
    }

    #app.is-dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="app" aria-label="Carrusel 3D interactivo"></div>

  <div class="ui">
    <div class="headline">
      <div class="eyebrow">3D Project Orbit</div>
      <h1>Interactive Motion Showcase</h1>
      <p>
        Carrusel 3D inspirado en una experiencia editorial premium: tarjetas flotantes en órbita,
        arrastre con mouse, scroll controlado y micro-oscilaciones sutiles para una sensación viva.
      </p>
    </div>

    <div class="hint">
      <strong>Interacción:</strong><br />
      Arrastra para girar • usa el wheel para acelerar la rotación • mueve el cursor para un leve parallax.
    </div>
  </div>

  <!-- Librerías vía CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>

  <script>
    // =========================================================
    // REGISTRO DE PLUGIN GSAP
    // =========================================================
    gsap.registerPlugin(ScrollTrigger);

    // =========================================================
    // CONFIGURACIÓN GENERAL
    // =========================================================
    const container = document.getElementById('app');

    // Datos de ejemplo: puedes reemplazar fácilmente estas URLs por imágenes reales de proyectos.
    const projects = [
      { title: 'Project 01', image: 'https://images.unsplash.com/photo-1497366754035-f200968a6e72?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 02', image: 'https://images.unsplash.com/photo-1518005020951-eccb494ad742?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 03', image: 'https://images.unsplash.com/photo-1524758631624-e2822e304c36?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 04', image: 'https://images.unsplash.com/photo-1505693416388-ac5ce068fe85?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 05', image: 'https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 06', image: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 07', image: 'https://images.unsplash.com/photo-1497366811353-6870744d04b2?auto=format&fit=crop&w=900&q=80' },
      { title: 'Project 08', image: 'https://images.unsplash.com/photo-1497215842964-222b430dc094?auto=format&fit=crop&w=900&q=80' }
    ];

    // =========================================================
    // ESCENA THREE.JS
    // =========================================================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a1018, 8, 22);

    const camera = new THREE.PerspectiveCamera(
      42,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0.35, 8.5);

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance'
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    // =========================================================
    // LUCES
    // =========================================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xbfd9ff, 1.8);
    keyLight.position.set(5, 4, 7);
    scene.add(keyLight);

    const fillLight = new THREE.PointLight(0x6e90ff, 2.2, 20, 2);
    fillLight.position.set(-4, 1.5, 3);
    scene.add(fillLight);

    const rimLight = new THREE.PointLight(0xffffff, 1.4, 16, 2);
    rimLight.position.set(0, -2, -2);
    scene.add(rimLight);

    // =========================================================
    // GRUPOS PRINCIPALES
    // =========================================================
    // orbitGroup: todo el anillo rota sobre este grupo.
    const orbitGroup = new THREE.Group();
    scene.add(orbitGroup);

    // floatingGroup: permite aplicar un suave movimiento global flotante.
    const floatingGroup = new THREE.Group();
    floatingGroup.add(orbitGroup);
    scene.add(floatingGroup);

    // =========================================================
    // HELPERS PARA TEXTURAS EN CANVAS
    // =========================================================
    function createRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    // Genera una textura tipo glass card con imagen y título.
    function createProjectCardTexture(image, title) {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 768;
      const ctx = canvas.getContext('2d');

      // Fondo general
      ctx.fillStyle = '#0f1722';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Área redondeada principal
      createRoundedRect(ctx, 24, 24, 976, 720, 38);
      ctx.save();
      ctx.clip();

      // Dibujamos la imagen cubriendo casi toda la tarjeta
      const imgAspect = image.width / image.height;
      const targetAspect = 976 / 720;
      let drawW, drawH, offsetX, offsetY;

      if (imgAspect > targetAspect) {
        drawH = 720;
        drawW = drawH * imgAspect;
        offsetX = 24 - (drawW - 976) / 2;
        offsetY = 24;
      } else {
        drawW = 976;
        drawH = drawW / imgAspect;
        offsetX = 24;
        offsetY = 24 - (drawH - 720) / 2;
      }

      ctx.drawImage(image, offsetX, offsetY, drawW, drawH);

      // Overlay oscuro para legibilidad
      const overlay = ctx.createLinearGradient(0, 460, 0, 744);
      overlay.addColorStop(0, 'rgba(7, 12, 18, 0.05)');
      overlay.addColorStop(1, 'rgba(7, 12, 18, 0.72)');
      ctx.fillStyle = overlay;
      ctx.fillRect(24, 24, 976, 720);

      // Línea sutil superior
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 2;
      createRoundedRect(ctx, 24, 24, 976, 720, 38);
      ctx.stroke();

      // Etiqueta pequeña
      ctx.fillStyle = 'rgba(223, 235, 247, 0.72)';
      ctx.font = '500 20px Inter, Arial, sans-serif';
      ctx.fillText('Featured Project', 66, 92);

      // Título inferior
      ctx.fillStyle = '#f7fbff';
      ctx.font = '600 52px Inter, Arial, sans-serif';
      ctx.fillText(title, 62, 660);

      // Subtexto
      ctx.fillStyle = 'rgba(225, 236, 248, 0.78)';
      ctx.font = '400 24px Inter, Arial, sans-serif';
      ctx.fillText('Immersive showcase / Motion-first experience', 64, 704);

      ctx.restore();

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      return texture;
    }

    // Genera la tarjeta central con logotipo tipográfico.
    function createCenterLogoTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');

      const bg = ctx.createLinearGradient(0, 0, 1024, 1024);
      bg.addColorStop(0, '#0d1623');
      bg.addColorStop(1, '#11161d');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, 1024, 1024);

      // Glow interno
      const glow = ctx.createRadialGradient(512, 420, 60, 512, 420, 440);
      glow.addColorStop(0, 'rgba(109, 155, 255, 0.16)');
      glow.addColorStop(1, 'rgba(109, 155, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, 1024, 1024);

      // Marco
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 4;
      createRoundedRect(ctx, 44, 44, 936, 936, 56);
      ctx.stroke();

      // Texto principal tipo logotipo
      ctx.fillStyle = '#f4f8fe';
      ctx.textAlign = 'center';
      ctx.font = '600 178px Inter, Arial, sans-serif';
      ctx.fillText('XX', 512, 460);

      ctx.font = '500 44px Inter, Arial, sans-serif';
      ctx.fillStyle = 'rgba(223, 235, 247, 0.8)';
      ctx.fillText('MOTION STUDIO', 512, 555);

      ctx.font = '400 28px Inter, Arial, sans-serif';
      ctx.fillStyle = 'rgba(223, 235, 247, 0.58)';
      ctx.fillText('3D Interactive Portfolio Ring', 512, 620);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      return texture;
    }

    // =========================================================
    // CREACIÓN DE TARJETAS
    // =========================================================
    const loader = new THREE.TextureLoader();
    const cardMeshes = [];
    const cardWrappers = []; // wrapper para animar tilt/float individual

    function createCardMesh(texture, width = 2.2, height = 1.55) {
      const geometry = new THREE.PlaneGeometry(width, height, 18, 18);
      const material = new THREE.MeshPhysicalMaterial({
        map: texture,
        transparent: true,
        roughness: 0.42,
        metalness: 0.08,
        clearcoat: 0.18,
        clearcoatRoughness: 0.45,
        side: THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    function createSoftShadow(width = 2.4, height = 1.75) {
      const shadowCanvas = document.createElement('canvas');
      shadowCanvas.width = 256;
      shadowCanvas.height = 256;
      const ctx = shadowCanvas.getContext('2d');

      const gradient = ctx.createRadialGradient(128, 128, 18, 128, 128, 110);
      gradient.addColorStop(0, 'rgba(0,0,0,0.30)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 256, 256);

      const texture = new THREE.CanvasTexture(shadowCanvas);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        depthWrite: false
      });

      const plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -0.95;
      return plane;
    }

    // Tarjeta central (logo)
    const centerCard = createCardMesh(createCenterLogoTexture(), 2.6, 2.6);
    centerCard.position.set(0, 0, 0);
    orbitGroup.add(centerCard);

    const centerGlowMaterial = new THREE.SpriteMaterial({
      map: (() => {
        const c = document.createElement('canvas');
        c.width = 256;
        c.height = 256;
        const cx = c.getContext('2d');
        const g = cx.createRadialGradient(128, 128, 16, 128, 128, 110);
        g.addColorStop(0, 'rgba(109, 155, 255, 0.34)');
        g.addColorStop(1, 'rgba(109, 155, 255, 0)');
        cx.fillStyle = g;
        cx.fillRect(0, 0, 256, 256);
        const t = new THREE.CanvasTexture(c);
        t.colorSpace = THREE.SRGBColorSpace;
        return t;
      })(),
      transparent: true,
      depthWrite: false
    });
    const centerGlow = new THREE.Sprite(centerGlowMaterial);
    centerGlow.scale.set(4.8, 4.8, 1);
    centerGlow.position.set(0, 0, -0.6);
    orbitGroup.add(centerGlow);

    // =========================================================
    // CARGA DE IMÁGENES Y MONTAJE DEL ANILLO
    // =========================================================
    const radius = 4.2;
    const verticalWave = 0.24;

    Promise.all(
      projects.map((project) =>
        new Promise((resolve) => {
          loader.load(project.image, (texture) => {
            const image = texture.image;
            const finalTexture = createProjectCardTexture(image, project.title);
            resolve({ ...project, texture: finalTexture });
          });
        })
      )
    ).then((loadedProjects) => {
      loadedProjects.forEach((project, index) => {
        // Wrapper: permite mover y rotar cada tarjeta sin afectar la lógica de posicionamiento principal
        const wrapper = new THREE.Group();

        const mesh = createCardMesh(project.texture);
        const shadow = createSoftShadow();

        wrapper.add(mesh);
        wrapper.add(shadow);

        const angle = (index / loadedProjects.length) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = Math.sin(index * 0.85) * verticalWave;

        wrapper.position.set(x, y, z);

        // La tarjeta mira al centro para mantener el efecto de anillo envolvente
        mesh.lookAt(0, y * 0.45, 0);

        // Ligero giro adicional para un look más orgánico/editorial
        mesh.rotation.z = Math.sin(index * 1.3) * 0.035;

        orbitGroup.add(wrapper);
        cardMeshes.push(mesh);
        cardWrappers.push(wrapper);

        // Micro-oscilación individual con GSAP (sinusoidal, sutil, perpetua)
        gsap.to(wrapper.position, {
          y: `+=${0.18 + (index % 3) * 0.03}`,
          duration: 1.8 + index * 0.11,
          repeat: -1,
          yoyo: true,
          ease: 'sine.inOut'
        });

        gsap.to(mesh.rotation, {
          z: mesh.rotation.z + (index % 2 === 0 ? 0.04 : -0.04),
          x: (index % 2 === 0 ? 0.025 : -0.025),
          duration: 2.2 + index * 0.07,
          repeat: -1,
          yoyo: true,
          ease: 'sine.inOut'
        });
      });
    });

    // =========================================================
    // ESTADO INTERACTIVO
    // =========================================================
    const state = {
      rotationY: 0,
      targetRotationY: 0,
      velocityY: 0,
      isDragging: false,
      dragStartX: 0,
      dragStartRotation: 0,
      pointerX: 0,
      pointerY: 0,
      parallaxX: 0,
      parallaxY: 0
    };

    // =========================================================
    // DRAG CON MOUSE / POINTER
    // =========================================================
    function onPointerDown(e) {
      state.isDragging = true;
      state.dragStartX = e.clientX;
      state.dragStartRotation = state.targetRotationY;
      container.classList.add('is-dragging');
    }

    function onPointerMove(e) {
      // Valores normalizados para parallax suave
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      const ny = (e.clientY / window.innerHeight) * 2 - 1;
      state.pointerX = nx;
      state.pointerY = ny;
      state.parallaxX = nx * 0.24;
      state.parallaxY = ny * 0.14;

      if (!state.isDragging) return;

      const deltaX = e.clientX - state.dragStartX;
      const dragStrength = 0.0065;
      state.targetRotationY = state.dragStartRotation + deltaX * dragStrength;
      state.velocityY = deltaX * 0.00012;
    }

    function onPointerUp() {
      state.isDragging = false;
      container.classList.remove('is-dragging');
    }

    container.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointerleave', onPointerUp);

    // =========================================================
    // WHEEL PARA ROTACIÓN ADICIONAL
    // =========================================================
    window.addEventListener(
      'wheel',
      (e) => {
        state.targetRotationY += e.deltaY * 0.0011;
      },
      { passive: true }
    );

    // =========================================================
    // SCROLL VIRTUAL CON GSAP + SCROLLTRIGGER
    // =========================================================
    // Creamos un contenedor virtual muy alto para que el scroll tenga recorrido.
    const virtualScroller = document.createElement('div');
    virtualScroller.style.position = 'absolute';
    virtualScroller.style.top = '0';
    virtualScroller.style.left = '0';
    virtualScroller.style.width = '1px';
    virtualScroller.style.height = '500vh';
    virtualScroller.style.pointerEvents = 'none';
    virtualScroller.style.opacity = '0';
    document.body.appendChild(virtualScroller);

    const scrollController = { progress: 0 };

    gsap.to(scrollController, {
      progress: 1,
      ease: 'none',
      scrollTrigger: {
        trigger: virtualScroller,
        start: 'top top',
        end: 'bottom bottom',
        scrub: 1.2
      },
      onUpdate: () => {
        // El scroll suma una rotación suave adicional sobre el carrusel.
        state.targetRotationY = state.targetRotationY * 0.985 + scrollController.progress * Math.PI * 2.2 * 0.015;
      }
    });

    // También animamos ciertos detalles visuales con el avance del scroll.
    gsap.to(floatingGroup.position, {
      y: 0.28,
      ease: 'none',
      scrollTrigger: {
        trigger: virtualScroller,
        start: 'top top',
        end: 'bottom bottom',
        scrub: 1.4
      }
    });

    gsap.to(camera.position, {
      z: 7.7,
      ease: 'none',
      scrollTrigger: {
        trigger: virtualScroller,
        start: 'top top',
        end: 'bottom bottom',
        scrub: 1.6
      }
    });

    // =========================================================
    // ANIMACIÓN DE ENTRADA
    // =========================================================
    orbitGroup.scale.set(0.86, 0.86, 0.86);
    orbitGroup.rotation.y = -0.4;

    gsap.to(orbitGroup.scale, {
      x: 1,
      y: 1,
      z: 1,
      duration: 1.8,
      ease: 'power3.out'
    });

    gsap.to(orbitGroup.rotation, {
      y: 0,
      duration: 2.1,
      ease: 'power3.out'
    });

    gsap.to(centerCard.rotation, {
      z: 0.02,
      duration: 1.8,
      repeat: -1,
      yoyo: true,
      ease: 'sine.inOut'
    });

    gsap.to(centerGlow.scale, {
      x: 5.1,
      y: 5.1,
      duration: 2.6,
      repeat: -1,
      yoyo: true,
      ease: 'sine.inOut'
    });

    // =========================================================
    // LOOP DE RENDER
    // =========================================================
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const elapsed = clock.getElapsedTime();

      // Suavizado de la rotación (lerp / damping)
      state.rotationY += (state.targetRotationY - state.rotationY) * 0.07;
      state.velocityY *= 0.94;
      state.targetRotationY += state.velocityY;

      // Rotación principal del anillo
      orbitGroup.rotation.y = state.rotationY;

      // Flotación global sutil
      floatingGroup.position.y += ((Math.sin(elapsed * 0.85) * 0.08) - floatingGroup.position.y) * 0.03;
      floatingGroup.rotation.x += ((-state.parallaxY * 0.18) - floatingGroup.rotation.x) * 0.05;
      floatingGroup.rotation.y += ((state.parallaxX * 0.14) - floatingGroup.rotation.y) * 0.05;

      // Parallax de cámara muy leve para respuesta al cursor
      camera.position.x += ((state.parallaxX * 0.28) - camera.position.x) * 0.035;
      camera.position.y += ((0.35 - state.parallaxY * 0.18) - camera.position.y) * 0.035;
      camera.lookAt(0, 0.1, 0);

      // Actualizamos cada tarjeta para que siempre mire suavemente hacia afuera/centro y mantenga presencia espacial
      cardWrappers.forEach((wrapper, i) => {
        const baseY = wrapper.position.y;
        wrapper.rotation.y = Math.sin(elapsed * 0.8 + i) * 0.02;
        wrapper.rotation.x = Math.cos(elapsed * 0.75 + i * 0.5) * 0.012;

        // Leve respiración espacial en Z para enriquecer profundidad
        wrapper.position.z += (Math.sin(elapsed * 1.2 + i * 0.9) * 0.035) * 0.02;
      });

      renderer.render(scene, camera);
    }

    animate();

    // =========================================================
    // RESPONSIVE / RESIZE
    // =========================================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      ScrollTrigger.refresh();
    });
  </script>
</body>
</html>
